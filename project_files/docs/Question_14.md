# 14. `PART 1` Explain the NAT/PAT address translation mechanisms. `PART 2` Basic notions concerning data structures: modelling, abstraction, abstract data types. Elementary data structures: lists, stacks, queues. Sets, multisets, arrays. The representation of trees, tree traversal, deletion and insertion.

## Part 1

### Network address translation

NAT or network address translation is a technology that runs on the edge devices between a wide area network or the internet and local area networks. These edge devices are usually routers. The role of NAT is to convert public IP addresses to private IP addresses or map public IP addresses to private IP addresses. Public IP addresses are registered IP addresses that can be found on the internet, on the other hand, private IP addresses are bound to their local network and cannot connect to the internet on their own. Organizations and houses having multiple devices choose from a set of defined ranges of private IP addresses, one such range is from 192.168.0.1 to 192.168.255.255, this allows for 216 private addresses, which is a huge number. Thus, two separate organizations can have devices with the same private IP address. Now to connect a device having a private IP address to the internet, the edge device or the router will translate the private address to a public address, and this information is stored in a NAT table. The NAT table keeps a record of these mappings, this way the packets are routed to and from their correct endpoints. We have two basic types of NAT which are:

- SNAT or static NAT – Static NAT is when the edge device will do a one-to-one mapping between the public address and the private address. These mappings are written to the NAT table and do not change; thus they are static. This type of implementation includes lots of manual mapping when the network is set up, it is also wasteful since the organization has to buy as many public addresses as private addresses or end devices.
- DNAT or dynamic NAT – Dynamic NAT is when the edge device will have a pool of public addresses assigned to it. When a device on the local network requests to connect to the internet, the edge device will assign a public address to that private address dynamically from the pool of free public addresses. Once the device ends the connection or times out due to inactivity, the corresponding private address is freed up and put back into the pool of public addresses, ready to be reassigned to a new private address. This implementation is very costly since the organization has to purchase a pool of public addresses upfront, this is also wasteful.

### Port address translation

The IPv4 system uses a 32-bit address for the public IP addresses, which means we can have at most 232 IP addresses or around 4.3 billion public addresses. This was fine at the early times of the internet when we had a very small number of users, using the dial-up connection. Under the dial-up connection, a user would establish the connection and be assigned a public address, once the connection was over, that public address was freed up. But due to the explosion of the number of users connecting to the internet, especially the number of devices connecting to the internet per user, one single user might have a smart TV, laptop, mobile phone, smartwatch, a smart speaker connected to the internet. This caused us to run out of the 4.3 billion addresses on the IPv4 system. This is where PAT comes into play. PAT is port address translation, it is an upgrade to the NAT system where the edge device can have just one public IP address, which it can map to multiple local private addresses. In PAT each device on the network is assigned a port number, when a device on the private network connects to the internet, the private IP address is translated to the public IP address with the port number appended to it giving it a unique IP address. Returning packets are swapped back using the NAT table. Using PAT we can perform many to one mapping, which means multiple internal hosts can connect to the internet using a single public address. This makes PAT very cheap since the router has to have just one public IP address and it is not wasteful as well. The usage of PAT might become the thing of the past since the introduction of IPv6 which uses 64-bit addresses, which is more than enough to allow a separate public address to each device.

## Part 2

### Data structure

A data structure is a data organization, management, and storage format that enables efficient access and modification. A data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data. Data structures serve as the basis for abstract data types or ADT. ADT defines the logical form of the data type; the data structure implements the physical form of the data type. Different types of data structures are suited for different kinds of applications, some are highly specialized to specific tasks like a compiler implementation usually uses hash tables to look up identifiers.

### Data modeling

Data modeling is the process of creating a visual representation of either a whole information system or parts of it to communicate connections between data points and structures. The goal is to illustrate the types of data used and stored within the system, the relationships among these data types, the ways the data can be grouped and organized, and its formats and attributes. Data models are built around business needs. Rules and requirements are defined upfront through feedback from business stakeholders so they can be incorporated into the design of a new system or adapted to the existing one. Data can be modeled at various levels of abstraction. The process begins by getting the business requirements, these are translated into data structures to formulate a concrete database design. Data modeling uses standardized schemas and formal techniques which makes it consistent and easy to fix later by someone who did not design the model in the first place. Data models can be categorized into three categories with decreasing levels of abstraction. These models are:
Conceptual data model – They offer a bigger picture view of what the system will contain and how it will be organized. Conceptual models are created as a part of the initial requirement gathering process. Typically, they include entity classes, their characteristics and constraints, and relationships between them.
Logical data model – They are less abstract and provide more detail about the concepts and relationships in the domain. One of several formal data modeling notations is followed. These indicate data attributes, such as data types and their lengths, and show relationships among the entities. Logical data models don’t specify any technical system requirement.
Physical data model – These provide a schema for how the data will be physically stored within a database, they are the least abstract of all three models. They offer a final design that can be implemented as a relational database, including tables that show the relationships among entities as well as the primary keys and the foreign keys that will be used to maintain the relationships. Physical data models can include database management system-specific properties.

### Abstract data types

Abstract data types are an abstraction of a data structure that provides only the interface to which the data structure must adhere. The interface does not give any specific details about how the data structure should be implemented or in what programming language. The reason we choose to abstract the implementation of the data structure is that different programming languages have a different strategies to implement the same data structure, for example in C a data structure is implemented using a structure or a struct, but in C++ a data structure is implemented using objects and classes. An example of an abstract data type is a stack that can be created with both linked list and array, but we do not need to know the implementation, just the interface or the operations this stack can perform.

### List

A list or a linked list is a linear data structure. A linked list is like a chain of nodes, where each node contains information like data and a pointer to the succeeding node in the chain. There’s a head pointer, which points to the first element of the linked list, and if the list is empty then it simply points to null or nothing. Linked lists are used to implement file systems, hash tables, etc. A linked list can be a singly linked list or unidirectional and double linked list or bidirectional. We can insert an element at the end of a linked list, delete a given element, search for elements or check if the linked list is empty.

### Stack

Stack is an elementary data structure where we place the latest data in the memory in an order that the last one appears first. A stack is like piling books which is the data in this analogy, one on top of the other, if we have to remove the last element then we can remove the element at the top of the stack or remove the book at the top, but if we want to remove a book somewhere in the middle, then we have to remove all books on top of the one which we need to remove first. This is the LIFO or last in first out method. Some basic operations we can use on stacks are push when we insert an element to the top, pop when we remove the top element and return it, and top which returns the top element of the stack without removing it. We can also check if the stack is empty or not.

### Queue

Queues are linear data structures that store elements sequentially. They are like a stack but instead of using the last in first out method LIFO, it uses the first in first out or FIFO method. As the name implies, it is like a queue, it’s like people standing in a ticket line, where people are the data, the person at the very front will get the ticket first, more people will be added at the back of the line and the person who came early will get the ticket before a person who came later. Elements are inserted at the back and accessed at the front of the queue. Some operations we can perform on queues are inserting an element to the end of the queue, removing an element at the start of the queue, returning the first element of the queue, and checking if the queue is empty.

### Set

Set is a data structure that can store any number of unique values in any order. Sets do not allow non-repeated values. Sets can use the mathematical set operations like union, intersection, and difference. We can create hash tables using sets, has tables are data structures where we have key-value pairs, we can add a unique key and its value, we can also remove a key that will remove its value, and we can change the value of a key by using the key name as the index. In the Python programming language, dictionaries are hash tables. A multiset is a data structure that stores and manipulates an unordered collection of elements that may be repeated.

### Array

An array the is most widely used data structure. Each data element is assigned a positive numerical value called the index, which corresponds to the position of that item in the array. Most languages define the starting index of the array as 0 except for MATLAB which starts at 1, this is actually because the index serves as an offset to the memory location the element is stored in when the processor wants access the element. One dimensional array contains a single chain of elements or vector data, multi-dimensional arrays contain arrays within arrays like tensors. We can insert an element at a given index of the array, we can get an element from any index position, delete an element at any index and get the size of the array.

### Tree

A tree is a non-linear data structure, this is in contrast with arrays, linked lists, stacks of a queue all of which are linear data structures. A tree data structure is organized hierarchically, there is one single top-level node called the root node, this root node had child nodes. Each node that has more child nodes of its own is called a parent node and nodes that do not have any child nodes are called a terminal node or a leaf node. A given branch of the tree terminates at a leaf node. We can create subtrees from a tree that is not the entire tree but a part of the original tree starting at some parent node and including all its descendent nodes. The depth of a node is the length from the root to the given node. A common type of tree is the binary search tree. In a binary search tree, each node has two child nodes, except the lead nodes which have no child nodes. The value of a child node can also be null. This tree is arranged in a way so that every left node is less than its parent node which is less than all nodes on the right side. For example, if we have three elements, 4,5,6, we can place 5 at the root with 4 being the left child node and 6 being the right child node. Finding an element in such an arrangement is very fast since we already know if the left subtree would be less than or more than the given element to find, this way on each step we half the number of elements to search for.
Unlike linear data structures like arrays and linked lists which have only one logical way to traverse them, trees can be traversed in different ways. These ways are:

- Pre-order (Root Left Right) – In this method, the root node is visited first, then the left subtree, and finally the right subtree.
- In-order (Left Root Right) – In this method, the left subtree is visited first, then root, and then the right subtree.
- Post-order (Left Right Root) – In this method, the root is visited last, first, we traverse the left subtree, then the right, and finally the root.

Insertion works in a similar way to searching. We get the element and see if the root node is less than or more than it, based on that we go either left or right and repeat this on every node till we find the spot for it. If the inserted node is not a leaf node, then we have to copy the values of nodes affected by this addition and make them child nodes or parents’ nodes of the added node.

Deletion for leaf nodes is simple since we search for it and simply delete it. To delete a node with children, we need to find the inorder successor of that node, then copy it and subsequently change other nodes in the tree.
