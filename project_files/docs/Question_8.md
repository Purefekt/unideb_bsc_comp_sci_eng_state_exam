# 8. `PART 1` Concept, typical applications and requirements of embedded systems. Real-time and reactive systems. Embedded systems architecture. Hardware and software layers. Embedded software: system software layer and application software layer. `PART 2` Functions and services of the MRTG and Nagios network management systems.

## Part 1

### Requirements of embedded systems

An embedded system is any computer system contained within a product or embedded into another product that is not described as a computer. These are different from general-purpose computers, instead, they are custom made for a given purpose, they run software on dedicated hardware which might be terrible as a general-purpose computer but will excel in the task it was made for. Embedded systems have three main components, hardware, software, and firmware. The requirements of embedded systems change as per the application, for example, an embedded system in a fire alarm might only have a very low power single microprocessor and some sensors and actuators, it must operate in a wide range of temperature and humidity values and must consume as little energy as possible since it is highly likely that it will be working off a battery. Some other applications of embedded systems are digital watches, washing machines, cameras, automobiles, etc.

### Real-time and reactive systems

Real-time systems are computer systems that monitor, respond to, or control an external environment. The environment is connected to the computer system through sensors, actuators, and other I/O interfaces. This computer system must meet various timing and other constraints that are imposed on it by the real-time behavior of the external world to which it is interfaced. These systems are also called reactive systems because their primary purpose is to respond to or react to signals from their environment. These types of systems are usually a component of a larger system thus they are embedded systems.

### Embedded systems architecture

Embedded systems come in two broad architecture types, Von Neumann architecture and Harvard architecture. The von Neumann architecture was proposed by Hungarian computer scientists John Von Neumann. In this architecture, one data bus exists for both instruction and data. Because of this, the CPU does one operation at a time, it can either fetch an instruction from memory or perform a read/write operation on the data. A fetch and data operation cannot occur simultaneously. The processor takes two clock cycles to execute, it will fetch a code in a separate cycle and read/write in a separate cycle. This architecture is simple and less time-consuming.
The Harvard architecture on the other hand has separate storage and signal buses for instruction and data. Using separate internal buses, we can access the program instructions and data. This allows for fetch and reads/write operations to occur at the same time using different buses. The CPU can use a single clock cycle, this makes the design more complex and is more time-consuming.

### Hardware and software layers

The hardware in an embedded system is based around a microprocessor or microcontroller. The embedded system hardware also contains other elements like memory, I/O devices, expandable interfaces like a display or camera, chips for wireless communication protocols. The embedded system software is written to perform a particular function. It is typically written in a high-level format and then compiled down to provide code that can be lodged within a non-volatile memory within the hardware. For educational embedded system devices like raspberry-pi, the language to write software is typically python. For a wide range of embedded devices, we use embedded C++ or C. For mission-critical applications of embedded systems like the anti-lock brake system, the code could be written directly in assembly language to get the fastest response from the system.

### System and application software layer

The system software layer is the software that is designed to provide a platform for other software. System software includes operating systems like Windows or macOS, game engines like Unity and Unreal Engine, and software as a service application like Amazon Web Services and Microsoft Azure. For embedded systems like raspberry pi, the system software of choice is Raspberry Pi OS which is a Debian-based operating system or Unix-like system. This operating system was specially written for the ARM-based CISC processors which run these single board computers, that is why they are extremely optimized. This system software is very elaborate compared to a lot of other embedded systems, it offers a fully functioning graphical user interface, very close to macOS or windows in appearance. Users can install packages or pieces of fully functioning software using the APT or advanced package tool. On the other hand, we have the very simple embedded system Arduino, which uses the system software called Xinu and includes very basic features. Another tool called Protothreads can be used to execute linear code in C, and this can be used without any underlying operating system.
Application software on the other hand is software that performs very specific tasks for the end-user. The user will directly interact with a piece of this software, unlike system software that will run process abstract from the end-user, of course, the user can alter these system software processes but, in most cases, it will result in misbehavior of the system or even complete shutdown. Embedded application software is very specialized to the application the embedded system will be embedded in. The important thing about embedded application software compared to application software found on a general-purpose computer is that non or not all functions of embedded software are initiated or controlled via a human interface, but through machine interfaces instead. An example of embedded software can be for controlling lights in homes, this can run on a simple 8bit microcontroller with just a few kilobytes of memory on very little energy, compared to 64-bit modern processors using several gigabytes of memory to function in the case of general-purpose computers.

## Part 2

### MRTG

MRTG or multi-router traffic Grapher is a free software for monitoring and measuring the traffic load on network links. It allows the user to see traffic load on a network over time in a graphical form. It was originally built to monitor router traffic, but it has evolved as a tool to create graphs and statistics for almost anything. This software is written in Perl and runs on all major operating systems. MRTG uses the simple network management protocol or SNMP to send requests with two object identifiers OIDs to a device. The device, which must be SNMP-enabled, will have a management information base to look up the OID specified. After collecting the information, it will send back the saw data encapsulated in an SNMP protocol. MRTG records this data in a log on the client along with previously recorded data for the device. The software then creates an HTML document from the logs, containing a list of graphs detailing traffic for the selected devices in the server. MRTG can also be configured to run a script of command and parse its output for counter values. The MRTG website contains a large library of external scripts to enable monitoring of SQL database statistics, firewall rules, CPU fan RPMs, or other integer value data. MRTG measures two values, input, and output per target. It gets its data via an SNMP agent or through the output of a command line. The frequency of data collection is typically every five minutes, but it can be configured to different time intervals as well. It creates an HTML page per target that features four graphs as GIF or PNG images. Results are plotted vs time into the day, week, month, and year graphs, with the input as a full green area and the output as a blue line. MRTG will automatically scale the Y-axis of the graphs to show the most detail and it will calculate the max, average and current values for both input and output on the HTML page. We can also make it send warning emails if the values are above a certain threshold. The RRDtool or round-robin database tool is an implementation of MRTG which aims to handle time-series data like network bandwidth but also includes other data like temperature and CPU load. A lot of other widely used tools have been made which are based on RRDtool like Munin and Cacti.

### Nagios

Nagios is a free and open-source computer software application that monitors systems, networks, and infrastructure. Nagios offers to monitor and alerting services for servers, switches, and applications. It alerts users when things go wrong and alert them a second time when the problem has been resolved. It is continuous monitoring software which is a process to detect, report, and respond to all attacks which occur in the infrastructure. Continuous monitoring starts when the deployment is done on the production servers. There are several benefits to continuous monitoring like detecting all server and network problems, finding the root cause of the failure, helping reduce the maintenance cost, helping in troubleshooting the performance issues, helping updating infrastructure before it gets outdated, and monitoring the complete infrastructure every second. Nagios is a great choice since it can monitor database servers like SQL Server, Oracle, MySQL, Postgres, and others, it gives application-level information and also allows for protocol monitoring like HTTP, FTP SNMP, and SSH protocol monitoring, provides active development, it has an excellent community of open-source developers working hard to make it as bug-free as possible, it runs on virtually all operating systems, and it can ping to see if the host is reachable. Nagios helps in getting rid of periodic testing, it detects split-second failures and reduces maintenance cost without sacrificing performance. It also provides timely notification to the management of control and breakdown. Nagios has a server-agent architecture. The Nagios server is installed on the host and plugins are installed on the remote servers which are to be monitored. Nagios sends a signal through a process scheduler to run the plugins on the local or remote servers. These plugins collect the data like CPU usage and memory usage and send it back to the scheduler, then the process schedules send the notification to the admins and update the Nagios graphical user interface.
